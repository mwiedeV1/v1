<?v1
/*
  Astronomical functions
  ======================

  Sun and Moon positions:
  Source code ported from Arnold Barmettler, www.astronomie.info / www.CalSky.com
  based on algorithms by Peter Duffett-Smith's great and easy book
  'Practical Astronomy with your Calculator'.
  http://lexikon.astronomie.info/java/sunmoon/

  Planet positions:
  Source code ported from Stephen R. Schmitt
  https://codepen.io/lulunac27/pen/NRoyxE
*/

require_once ("math_utils.inc.v1");

const EMPTY_ASTRO_STR = "---";

moonPhases = array ("New moon", "Increasing sickle", "First quarter", "Increasing moon", "Full moon", "Decreasing moon", "Last quarter", "Decreasing sickle", "New moon");
starSigns = signs= array ("Aries", "Taurus", "Gemini", "Cancer", "Leo", "Virgo", "Libra", "Scorpio", "Sagittarius", "Capricorn", "Aquarius", "Pisces");
planets = array("Mercury", "Venus", "Sun", "Mars", "Jupiter", "Saturn", "Uranus", "Neptune", "Pluto");

function round100000(x)
{
	return(round(100000*x)/100000);
}
function round10000(x)
{
	return(round(10000*x)/10000);
}
function round1000(x)
{
	return(round(1000*x)/1000);
}
function round100(x)
{
	return(round(100*x)/100);
}
function round10(x)
{
	return(round(10*x)/10);
}

function isNaN (v)
{
	v = strtolower (v);
	return (strpos (v, "nan")!==false || strpos (v, "ind")!==false);
};

function HHMM(hh, fEmpty=true)
{
	if (fEmpty && hh==0)
		return EMPTY_ASTRO_STR;
	m = frac(hh)*60.0;
	h = abs (intval(hh));
	if (m>=59.5) {
		if (h<23) h++;
		else h=0;
		m -=60.0;
	}
	m = round(m);
	r = round1000(hh);
	if (isNaN(r))
		hStr = fEmpty ? EMPTY_ASTRO_STR : "never";
	else
		hStr = fEmpty ? sprintf ("%.2u:%.2u = %s", h, m, r) : sprintf ("%.2u:%.2u", h, m);
	return hStr;
}

function HHMMSS(hh, fEmpty=true)
{
	if (fEmpty && hh==0)
		return EMPTY_ASTRO_STR;
	m = frac(hh)*60;
	h = abs (intval(hh));
	s = frac(m)*60;
	m = intval(m);
	if (s>=59.5) {
		if (m<60) m++;
		else m=0;
		s -=60.0;
	}
	if (m>=60)   {
		if (h<23) h++;
		else h=0;
		m -=60;
	}
	s = round(s);
	r = round1000(hh);
	if (isNaN(r))
		hStr = fEmpty ? EMPTY_ASTRO_STR : "never";
	else
		hStr = fEmpty ? sprintf ("%.2u:%.2u:%.2u = %s", h, m, s, r) : sprintf ("%.2u:%.2u:%.2u", h, m, s);
	return hStr;
}

function StarSign(lon)
{
	global starSigns;
	return( starSigns[floor(lon*DEG/30)] );
}

// Calculate Julian date: valid only from 1.3.1901 to 28.2.2100
function CalcJD(day,month,year)
{
	jd = 2415020.5-64; // 1.1.1900 - correction of algorithm
	if (month<=2) {
		year--;
		month += 12;
	}
	jd += intval( (year-1900)*365.25 );
	jd += intval( 30.6001*(1+month) );
	return(jd + day);
}

// Julian Date to Greenwich Mean Sidereal Time
function GMST(JD)
{
	UT = frac(JD-0.5)*24.0; // UT in hours
	JD = floor(JD-0.5)+0.5;   // JD at 0 hours UT
	T = (JD-2451545.0)/36525.0;
	T0 = 6.697374558 + T*(2400.051336 + T*0.000025862);
	return(fmod(T0+UT*1.002737909, 24.0));
}

// Convert Greenweek mean sidereal time to UT
function GMST2UT(JD, gmst)
{
	JD = floor(JD-0.5)+0.5;   // JD at 0 hours UT
	T = (JD-2451545.0)/36525.0;
	T0 = fmod(6.697374558 + T*(2400.051336 + T*0.000025862), 24.0);
	// UT = 0.9972695663*fmod((gmst-T0), 24.);
	UT = 0.9972695663*((gmst-T0));
	return(UT);
}

// Local Mean Sidereal Time, geographical longitude in radians, East is positive
function GMST2LMST(gmst, lon)
{
	lmst = fmod(gmst+DEG*lon/15, 24.0);
	return( lmst );
}

// Transform ecliptical coordinates (lon/lat) to equatorial coordinates (RA/dec)
function Ecl2Equ(coor, TDT)
{
	T = (TDT-2451545.0)/36525.0; // Epoch 2000 January 1.5
	eps = (23.0+(26+21.45/60.0)/60.0 + T*(-46.815 +T*(-0.0006 + T*0.00181) )/3600.0 )*RAD;
	coseps = cos(eps);
	sineps = sin(eps);

	sinlon = sin(coor["lon"]);
	coor["ra"]  = mod2pi( atan2( (sinlon*coseps-tan(coor["lat"])*sineps), cos(coor["lon"]) ) );
	coor["dec"] = asin( sin(coor["lat"])*coseps + cos(coor["lat"])*sineps*sinlon );

	return coor;
}

// Transform equatorial coordinates (RA/Dec) to horizonal coordinates (azimuth/altitude)
// Refraction is ignored
function Equ2Altaz(coor, TDT, geolat, lmst)
{
	cosdec = cos(coor["dec"]);
	sindec = sin(coor["dec"]);
	lha = lmst - coor["ra"];
	coslha = cos(lha);
	sinlha = sin(lha);
	coslat = cos(geolat);
	sinlat = sin(geolat);

	N = -cosdec * sinlha;
	D = sindec * coslat - cosdec * coslha * sinlat;
	coor["az"] = mod2pi( atan2(N, D) );
	coor["alt"] = asin( sindec * sinlat + cosdec * coslha * coslat );

	return coor;
}

// Transform geocentric equatorial coordinates (RA/Dec) to topocentric equatorial coordinates
function GeoEqu2TopoEqu(coor, observer, lmst)
{
	cosdec = cos(coor["dec"]);
	sindec = sin(coor["dec"]);
	coslst = cos(lmst);
	sinlst = sin(lmst);
	coslat = cos(observer["lat"]); // we should use geocentric latitude, not geodetic latitude
	sinlat = sin(observer["lat"]);
	rho = observer["radius"]; // observer-geocenter in Kilometer

	x = coor["distance"]*cosdec*cos(coor["ra"]) - rho*coslat*coslst;
	y = coor["distance"]*cosdec*sin(coor["ra"]) - rho*coslat*sinlst;
	z = coor["distance"]*sindec - rho*sinlat;

	coor["distanceTopocentric"] = sqrt(x*x + y*y + z*z);
	coor["decTopocentric"] = asin(z/coor["distanceTopocentric"]);
	coor["raTopocentric"] = mod2pi( atan2(y, x) );

	return coor;
}

// Calculate cartesian from polar coordinates
function EquPolar2Cart( lon, lat, distance )
{
	cart = array ();
	rcd = cos(lat)*distance;
	cart["x"]= rcd*cos(lon);
	cart["y"] = rcd*sin(lon);
	cart["z"] = distance * sin(lat);
	return(cart);
}

// Calculate observers cartesian equatorial coordinates (x,y,z in celestial frame)
// from geodetic coordinates (longitude, latitude, height above WGS84 ellipsoid)
// Currently only used to calculate distance of a body from the observer
function Observer2EquCart( lon, lat, height, gmst )
{
	flat = 298.257223563; // WGS84 flatening of earth
	aearth = 6378.137; // GRS80/WGS84 semi major axis of earth ellipsoid
	cart = array ();
	// Calculate geocentric latitude from geodetic latitude
	co = cos (lat);
	si = sin (lat);
	fl = 1.0 - 1.0 / flat;
	fl = fl * fl;
	si = si * si;
	u = 1.0 / sqrt (co * co + fl * si);
	a = aearth * u + height;
	b = aearth * fl * u + height;
	radius = sqrt (a * a * co * co + b * b * si); // geocentric distance from earth center
	cart["y"] = acos (a * co / radius); // geocentric latitude, DEG
	cart["x"] = lon; // longitude stays the same
	if (lat < 0.0) {
		cart["y"] = -cart["y"];    // adjust sign
	}
	cart = EquPolar2Cart( cart["x"], cart["y"], radius ); // convert from geocentric polar to geocentric cartesian, with regard to Greenwich
	// rotate around earth's polar axis to align coordinate system from Greenwich to vernal equinox
	x=cart["x"];
	y=cart["y"];
	rotangle = gmst/24*2*PI; // sideral time gmst given in hours. Convert to radians
	cart["x"] = x*cos(rotangle)-y*sin(rotangle);
	cart["y"] = x*sin(rotangle)+y*cos(rotangle);
	cart["radius"] = radius;
	cart["lon"] = lon;
	cart["lat"] = lat;
	return(cart);
}

// Calculate coordinates for Sun
// Coordinates are accurate to about 10s (right ascension)
// and a few minutes of arc (declination)
function SunPosition(TDT, geolat=null, lmst=null)
{
	D = TDT-2447891.5;

	eg = 279.403303*RAD;
	wg = 282.768422*RAD;
	e  = 0.016713;
	a  = 149598500; // km
	diameter0 = 0.533128*RAD; // angular diameter of Moon at a distance

	MSun = 360*RAD/365.242191*D+eg-wg;
	nu = MSun + 360.0*RAD/PI*e*sin(MSun);

	sunCoor = array ();
	sunCoor["lon"] =  mod2pi(nu+wg);
	sunCoor["lat"] = 0;
	sunCoor["anomalyMean"] = MSun;

	sunCoor["distance"] = (1-pow(e,2))/(1+e*cos(nu)); // distance in astronomical units
	sunCoor["diameter"] = diameter0/sunCoor["distance"]; // angular diameter in radians
	sunCoor["distance"] *= a; // distance in km
	sunCoor["parallax"] = 6378.137/sunCoor["distance"];  // horizonal parallax

	sunCoor = Ecl2Equ(sunCoor, TDT);

	// Calculate horizonal coordinates of sun, if geographic positions is given
	if (geolat!=null && lmst!=null) {
		sunCoor = Equ2Altaz(sunCoor, TDT, geolat, lmst);
	}

	sunCoor["sign"] = StarSign(sunCoor["lon"]);
	return sunCoor;
}

// Calculate data and coordinates for the Moon
// Coordinates are accurate to about 1/5 degree (in ecliptic coordinates)
function MoonPosition(sunCoor, TDT, observer=null, lmst=null)
{
	D = TDT-2447891.5;

	// Mean Moon orbit elements as of 1990.0
	l0 = 318.351648*RAD;
	P0 =  36.340410*RAD;
	N0 = 318.510107*RAD;
	i  = 5.145396*RAD;
	e  = 0.054900;
	a  = 384401; // km
	diameter0 = 0.5181*RAD; // angular diameter of Moon at a distance
	parallax0 = 0.9507*RAD; // parallax at distance a

	l = 13.1763966*RAD*D+l0;
	MMoon = l-0.1114041*RAD*D-P0; // Moon's mean anomaly M
	N = N0-0.0529539*RAD*D; // Moon's mean ascending node longitude
	C = l-sunCoor["lon"];
	Ev = 1.2739*RAD*sin(2*C-MMoon);
	Ae = 0.1858*RAD*sin(sunCoor["anomalyMean"]);
	A3 = 0.37*RAD*sin(sunCoor["anomalyMean"]);
	MMoon2 = MMoon+Ev-Ae-A3;  // corrected Moon anomaly
	Ec = 6.2886*RAD*sin(MMoon2);  // equation of centre
	A4 = 0.214*RAD*sin(2*MMoon2);
	l2 = l+Ev+Ec-Ae+A4; // corrected Moon's longitude
	V = 0.6583*RAD*sin(2*(l2-sunCoor["lon"]));
	l3 = l2+V; // true orbital longitude;

	N2 = N-0.16*RAD*sin(sunCoor["anomalyMean"]);

	moonCoor = array ();
	moonCoor["lon"] = mod2pi( N2 + atan2( sin(l3-N2)*cos(i), cos(l3-N2) ) );
	moonCoor["lat"] = asin( sin(l3-N2)*sin(i) );
	moonCoor["orbitLon"] = l3;

	moonCoor = Ecl2Equ(moonCoor, TDT);
	// relative distance to semi mayor axis of lunar oribt
	moonCoor["distance"] = (1-pow(e,2)) / (1+e*cos(MMoon2+Ec) );
	moonCoor["diameter"] = diameter0/moonCoor["distance"]; // angular diameter in radians
	moonCoor["parallax"] = parallax0/moonCoor["distance"]; // horizontal parallax in radians
	moonCoor["distance"] *= a; // distance in km

	// Calculate horizonal coordinates of sun, if geographic positions is given
	if (observer!=null && lmst!=null) {

		// transform geocentric coordinates into topocentric (==observer based) coordinates
		moonCoor = GeoEqu2TopoEqu(moonCoor, observer, lmst);
		moonCoor["raGeocentric"] = moonCoor["ra"]; // backup geocentric coordinates
		moonCoor["decGeocentric"] = moonCoor["dec"];
		moonCoor["ra"]=moonCoor["raTopocentric"];
		moonCoor["dec"]=moonCoor["decTopocentric"];
		moonCoor = Equ2Altaz(moonCoor, TDT, observer["lat"], lmst); // now ra and dec are topocentric
	}

	// Age of Moon in radians since New Moon (0) - Full Moon (pi)
	moonCoor["moonAge"] = mod2pi(l3-sunCoor["lon"]);
	moonCoor["phase"] = 0.5*(1-cos(moonCoor["moonAge"])); // Moon phase, 0-1

	global moonPhases;

	mainPhase = 1.0/29.53*360*RAD; // show 'Newmoon, 'Quarter' for +/-1 day arond the actual event
	p = fmod(moonCoor["moonAge"], 90.0*RAD);
	if (p < mainPhase || p > 90*RAD-mainPhase) p = 2*round(moonCoor["moonAge"] / (90.0*RAD));
	else p = 2*floor(moonCoor["moonAge"] / (90.0*RAD))+1;
	moonCoor["moonPhase"] = moonPhases[p];

	moonCoor["sign"] = StarSign(moonCoor["lon"]);
	return(moonCoor);
}

// Input true altitude in radians, Output: increase in altitude in degrees
function Refraction(alt)
{
	altdeg = alt*DEG;
	if (altdeg<-2 || altdeg>=90) return(0);

	pressure    = 1015;
	temperature = 10;
	if (altdeg>15) return( 0.00452*pressure/( (273+temperature)*tan(alt)) );

	y = alt;
	D = 0.0;
	P = (pressure-80)/930;
	Q = 0.0048*(temperature-10);
	y0 = y;
	D0 = D;

	for (i=0; i<3; i++) {
		N = y+(7.31/(y+4.4));
		N = 1.0/tan(N*RAD);
		D = N*P/(60.0+Q*(N+39.0));
		N = y-y0;
		y0 = D-D0-N;
		if ((N != 0) && (y0 != 0)) {
			N = y-N*(alt+D-y)/y0;
		}
		else {
			N = alt+D;
		}
		y0 = y;
		D0 = D;
		y = N;
	}
	return( D ); // Hebung durch Refraktion in radians
}

// returns Greenwich sidereal time (hours) of time of rise
// and set of object with coordinates coor.ra/coor.dec
// at geographic position lon/lat (all values in radians)
// Correction for refraction and semi-diameter/parallax of body is taken care of in function RiseSet
// h is used to calculate the twilights. It gives the required elevation of the disk center of the sun
function GMSTRiseSet(coor, lon, lat, h=null)
{
	h = (h == null) ? 0 : h; // set default value
	riseset = array();
//  tagbogen = acos(-tan(lat)*tan(coor.dec)); // simple formula if twilight is not required
	tagbogen = acos((sin(h) - sin(lat)*sin(coor["dec"])) / (cos(lat)*cos(coor["dec"])));

	riseset["transit"] =      DEG /15*(          coor["ra"]-lon);
	riseset["rise"]    = 24 + DEG /15*(-tagbogen+coor["ra"]-lon); // calculate GMST of rise of object
	riseset["set"]     =      DEG /15*( tagbogen+coor["ra"]-lon); // calculate GMST of set of object

	// using the modulo function fmod, the day number goes missing. This may get a problem for the moon
	riseset["transit"] = fmod(riseset["transit"], 24);
	riseset["rise"]    = fmod(riseset["rise"], 24);
	riseset["set"]     = fmod(riseset["set"], 24);

	return(riseset);
}

// Find GMST of rise/set of object from the two calculates
// (start)points (day 1 and 2) and at midnight UT(0)
function InterpolateGMST(gmst0, gmst1, gmst2, timefactor)
{
	return( (timefactor*24.07*gmst1- gmst0*(gmst2-gmst1)) / (timefactor*24.07+gmst1-gmst2) );
}

// JD is the Julian Date of 0h UTC time (midnight)
function RiseSet(jd0UT, coor1, coor2, lon, lat, timeinterval, altitude=null)
{
	// altitude of sun center: semi-diameter, horizontal parallax and (standard) refraction of 34'
	alt = 0; // calculate
	altitude = (altitude == null) ? 0 : altitude; // set default value

	// true height of sun center for sunrise and set calculation. Is kept 0 for twilight (ie. altitude given):
	if (!altitude) alt = 0.5*coor1["diameter"]-coor1["parallax"]+34/60*RAD;

	rise1 = GMSTRiseSet(coor1, lon, lat, altitude);
	rise2 = GMSTRiseSet(coor2, lon, lat, altitude);
	rise = array();

	// unwrap GMST in case we move across 24h -> 0h
	if (rise1["transit"] > rise2["transit "] && abs(rise1["transit"]-rise2["transit"])>18) rise2["transit"] += 24;
	if (rise1["rise"]    > rise2["rise"]    && abs(rise1["rise"]   -rise2["rise"])>18)    rise2["rise"] += 24;
	if (rise1["set"]     > rise2["set"]     && abs(rise1["set"]    -rise2["set"])>18)     rise2["set"]  += 24;
	T0 = GMST(jd0UT);
	//  T02 = T0-zone*1.002738; // Greenwich sidereal time at 0h time zone (zone: hours)

	// Greenwich sidereal time for 0h at selected longitude
	T02 = T0-lon*DEG/15*1.002738;
	if (T02 < 0) T02 += 24;

	if (rise1["transit"] < T02) {
		rise1["transit"] += 24;
		rise2["transit"] += 24;
	}
	if (rise1["rise"]    < T02) {
		rise1["rise"]    += 24;
		rise2["rise"]    += 24;
	}
	if (rise1["set"]     < T02) {
		rise1["set"]     += 24;
		rise2["set"]     += 24;
	}

	// Refraction and Parallax correction
	decMean = 0.5*(coor1["dec"]+coor2["dec"]);
	psi = acos(sin(lat)/cos(decMean));
	y = asin(sin(alt)/sin(psi));
	dt = 240*DEG*y/cos(decMean)/3600; // time correction due to refraction, parallax

	rise["transit"] = GMST2UT( jd0UT, InterpolateGMST( T0, rise1["transit"], rise2["transit"], timeinterval) );
	rise["rise"]    = GMST2UT( jd0UT, InterpolateGMST( T0, rise1["rise"],    rise2["rise"],    timeinterval) -dt );
	rise["set"]     = GMST2UT( jd0UT, InterpolateGMST( T0, rise1["set"],     rise2["set"],     timeinterval) +dt );

	return(rise);
}


// Find (local) time of sunrise and sunset, and twilights
// JD is the Julian Date of 0h local time (midnight)
// Accurate to about 1-2 minutes
// recursive: 1 - calculate rise/set in UTC in a second run
// recursive: 0 - find rise/set on the current local day. This is set when doing the first call to this function
function SunRise(JD, deltaT, lon, lat, zone, recursive)
{
	jd0UT = floor(JD-0.5)+0.5;   // JD at 0 hours UT
	coor1 = SunPosition(jd0UT+  deltaT/24/3600);
	coor2 = SunPosition(jd0UT+1+deltaT/24/3600); // calculations for next day's UTC midnight

	risetemp =  array ();
	rise = array ();
	// rise/set time in UTC.
	rise = RiseSet(jd0UT, coor1, coor2, lon, lat, 1);
	if (!recursive) { // check and adjust to have rise/set time on local calendar day
		if (zone>0) {
			// rise time was yesterday local time -> calculate rise time for next UTC day
			if (rise["rise"]>=24-zone || rise["transit"]>=24-zone || rise["set"]>=24-zone) {
				risetemp = SunRise(JD+1, deltaT, lon, lat, zone, 1);
				if (rise["rise"]>=24-zone) rise["rise"] = risetemp["rise"];
				if (rise["transit"] >=24-zone) rise["transit"] = risetemp["transit"];
				if (rise["set"] >=24-zone) rise["set"]  = risetemp["set"];
			}
		}
		else if (zone<0) {
			// rise time was yesterday local time -> calculate rise time for next UTC day
			if (rise["rise"]<-zone || rise["transit"]<-zone || rise["set"]<-zone) {
				risetemp = SunRise(JD-1, deltaT, lon, lat, zone, 1);
				if (rise["rise"]<-zone) rise["rise"] = risetemp["rise"];
				if (rise["transit"]<-zone) rise["transit"] = risetemp["transit"];
				if (rise["set"] <-zone) rise["set"]  = risetemp["set"];
			}
		}

		rise["transit"] = fmod(rise["transit"]+zone, 24);
		rise["rise"]    = fmod(rise["rise"]   +zone, 24);
		rise["set"]     = fmod(rise["set"]    +zone, 24);

		// Twilight calculation
		// civil twilight time in UTC.
		risetemp = RiseSet(jd0UT, coor1, coor2, lon, lat, 1, -6*RAD);
		rise["cicilTwilightMorning"] = fmod(risetemp["rise"] +zone, 24);
		rise["cicilTwilightEvening"] = fmod(risetemp["set"]  +zone, 24);

		// nautical twilight time in UTC.
		risetemp = RiseSet(jd0UT, coor1, coor2, lon, lat, 1, -12*RAD);
		rise["nauticalTwilightMorning"] = fmod(risetemp["rise"] +zone, 24);
		rise["nauticalTwilightEvening"] = fmod(risetemp["set"]  +zone, 24);

		// astronomical twilight time in UTC.
		risetemp = RiseSet(jd0UT, coor1, coor2, lon, lat, 1, -18*RAD);
		rise["astronomicalTwilightMorning"] = fmod(risetemp["rise"] +zone, 24);
		rise["astronomicalTwilightEvening"] = fmod(risetemp["set"]  +zone, 24);
	}
	return( rise );
}

// Find local time of moonrise and moonset
// JD is the Julian Date of 0h local time (midnight)
// Accurate to about 5 minutes or better
// recursive: 1 - calculate rise/set in UTC
// recursive: 0 - find rise/set on the current local day (set could also be first)
// returns '' for moonrise/set does not occur on selected day
function MoonRise(JD, deltaT, lon, lat, zone, recursive)
{
	timeinterval = 0.5;

	jd0UT = floor(JD-0.5)+0.5;   // JD at 0 hours UT
	suncoor1 = SunPosition(jd0UT+ deltaT/24/3600);
	coor1 = MoonPosition(suncoor1, jd0UT+ deltaT/24/3600);

	suncoor2 = SunPosition(jd0UT +timeinterval + deltaT/24/3600); // calculations for noon
	// calculations for next day's midnight
	coor2 = MoonPosition(suncoor2, jd0UT +timeinterval + deltaT/24/3600);

	risetemp = array();
	rise = array();

	// rise/set time in UTC, time zone corrected later.
	// Taking into account refraction, semi-diameter and parallax
	rise = RiseSet(jd0UT, coor1, coor2, lon, lat, timeinterval);

	if (!recursive) { // check and adjust to have rise/set time on local calendar day
		if (zone>0) {
			// recursive call to MoonRise returns events in UTC, zone ignored
			risetemp = MoonRise(JD-1, deltaT, lon, lat, zone, 1);

			if (rise["transit"] >= 24-zone || rise["transit"] < -zone) { // transit time is tomorrow local time
				if (risetemp["transit"] < 24-zone || risetemp["transit"] >= 48-zone) rise["transit"] = ""; // there is no moontransit today
				else {
					rise["transit"]  = risetemp["transit"];
					if (rise["transit"] >= 24) rise["transit"]-=24;
				}
			}

			if (rise["rise"] >= 24-zone || rise["rise"] < -zone) { // rise time is tomorrow local time
				if (risetemp["rise"] < 24-zone || risetemp["rise"] >= 48-zone) rise["rise"] = ""; // there is no moontransit today
				else {
					rise["rise"]  = risetemp["rise"];
					if (rise["rise"] >= 24) rise["rise"]-=24;
				}
			}

			if (rise["set"] >= 24-zone || rise["set"] < -zone) { // set time is tomorrow local time
				if (risetemp["set"] < 24-zone || risetemp["set"] >= 48-zone) rise["set"] = ""; // there is no moontransit today
				else {
					rise["set"]  = risetemp["set"];
					if (rise["set"] >= 24) rise["set"]-=24;
				}
			}


		}
		else if (zone<0) {
			// rise/set time was tomorrow local time -> calculate rise time for former UTC day
			if (rise["rise"]<-zone || rise["set"]<-zone || rise["transit"]<-zone) {
				risetemp = MoonRise(JD+1, deltaT, lon, lat, zone, 1);

				if (rise["rise"] < -zone) {
					if (risetemp["rise"] > -zone) rise["rise"] = ""; // there is no moonrise today
					else rise["rise"] = risetemp["rise"];
				}

				if (rise["transit"] < -zone) {
					if (risetemp["transit"] > -zone)  rise["transit"] = ""; // there is no moonset today
					else rise["transit"]  = risetemp["transit"];
				}

				if (rise["set"] < -zone) {
					if (risetemp["set"] > -zone)  rise["set"] = ""; // there is no moonset today
					else rise["set"]  = risetemp["set"];
				}
			}
		}

		if (rise["rise"])    rise["rise"] = fmod(rise["rise"]+zone, 24);    // correct for time zone, if time is valid
		if (rise["transit"]) rise["transit"]  = fmod(rise["transit"] +zone, 24); // correct for time zone, if time is valid
		if (rise["set"])     rise["set"]  = fmod(rise["set"] +zone, 24);    // correct for time zone, if time is valid

	}
	return( rise );
}

/*
  Compute sun and moon data
  Form values for input required: Year, Month, Day, Minute, Second, Zone (GMT Hours), Lat, Lon, DeltaT

  Example for Input:

  time = time ();
  form["Hour"]    = date ("%H", time);
  form["Minute"]  = date ("%i", time);
  form["Second"]  = date ("%s", time);
  form["Day"]     = date ("%j", time);
  form["Month"]   = date ("%m", time);
  form["Year"]    = date ("%Y", time);
  form["Zone"]    = date ("%Z", time) / 3600;
  form["DeltaT"]  = 65; // deltaT - difference among 'earth center' versus 'observered' time (TDT-UT), in seconds
  form["Lat"]     = 48.9174128;
  form["Lon"]     = 10.9518465;

  Return true or false on error. Use print_r (form) to see details.
*/
function ComputeSunMoon (&form)
{
	if (form["Year"]<=1900 || form["Year"]>=2100 ) {
		print ("Only years between 1900 - 2100 are allowed.");
		return false;
	}

	JD0 = CalcJD( form["Day"], form["Month"], form["Year"] );
	JD  = JD0 + (( form["Hour"] - form["Zone"]) + form["Minute"]/60 + (form["Second"]/3600)) /24;
	TDT = JD  + form["DeltaT"]/24/3600;

	lat = form["Lat"]*RAD; // geodetic latitude of observer on WGS84
	lon = form["Lon"]*RAD; // latitude of observer
	height = 0 * 0.001; // altiude of observer in meters above WGS84 ellipsoid (and converted to kilometers)

	gmst = GMST(JD);
	lmst = GMST2LMST(gmst, lon);

	observerCart = Observer2EquCart(lon, lat, height, gmst); // geocentric cartesian coordinates of observer

	sunCoor = SunPosition(TDT, lat, lmst*15*RAD); // Calculate data for the Sun at given time

	moonCoor = MoonPosition(sunCoor, TDT, observerCart, lmst*15*RAD); // Calculate data for the Moon at given time

	form["JD"] = round100000(JD);
	form["GMST"] = HHMMSS(gmst);
	form["LMST"] = HHMMSS(lmst);

	if (form["Minute"]<10) form["Minute"] = "0"+form["Minute"];
	if (form["Month"]<10) form["Month"] = "0"+form["Month"];

	form["SunLon"]  = round1000(sunCoor["lon"]*DEG);
	form["SunRA"] = HHMM(sunCoor["ra"]*DEG/15);
	form["SunDec"] = round1000(sunCoor["dec"]*DEG);
	form["SunAz"] = round100(sunCoor["az"]*DEG);
	form["SunAlt"] = round10(sunCoor["alt"]*DEG+Refraction(sunCoor["alt"]));  // including refraction

	form["SunSign"] = sunCoor["sign"];
	form["SunDiameter"] = round100(sunCoor["diameter"]*DEG*60); // angular diameter in arc seconds
	form["SunDistance"] = round10(sunCoor["distance"]);

	// Calculate distance from the observer (on the surface of earth) to the center of the sun
	sunCart = EquPolar2Cart(sunCoor["ra"], sunCoor["dec"], sunCoor["distance"]);
	form["SunDistanceObserver"] = round10( sqrt( pow(sunCart["x"]-observerCart["x"],2) + pow(sunCart["y"]-observerCart["y"],2) + pow(sunCart["z"]-observerCart["z"],2) ));

	// JD0: JD of 0h UTC time
	sunRise = SunRise(JD0, form["DeltaT"], lon, lat, form["Zone"], 0);

	form["SunRise"] = HHMM(sunRise["rise"]);
	form["SunTransit"] = HHMM(sunRise["transit"]);
	form["SunSet"] = HHMM(sunRise["set"]);

	form["SunCivilTwilightMorning"] = HHMM(sunRise["cicilTwilightMorning"]);
	form["SunCivilTwilightEvening"] = HHMM(sunRise["cicilTwilightEvening"]);
	form["SunNauticalTwilightMorning"] = HHMM(sunRise["nauticalTwilightMorning"]);
	form["SunNauticalTwilightEvening"] = HHMM(sunRise["nauticalTwilightEvening"]);
	form["SunAstronomicalTwilightMorning"] = HHMM(sunRise["astronomicalTwilightMorning"]);
	form["SunAstronomicalTwilightEvening"] = HHMM(sunRise["astronomicalTwilightEvening"]);

	form["MoonLon"] = round1000(moonCoor["lon"]*DEG);
	form["MoonLat"] = round1000(moonCoor["lat"]*DEG);
	form["MoonRA"]  = HHMM(moonCoor["ra"]*DEG/15);
	form["MoonDec"] = round1000(moonCoor["dec"]*DEG);
	form["MoonAz"] = round100(moonCoor["az"]*DEG);
	form["MoonAlt"] = round10(moonCoor["alt"]*DEG+Refraction(moonCoor["alt"]));  // including refraction
	form["MoonAge"] = round1000(moonCoor["moonAge"]*DEG);
	form["MoonPhaseNumber"] = round1000(moonCoor["phase"]);
	form["MoonPhase"] = moonCoor["moonPhase"];

	form["MoonSign"] = moonCoor["sign"];
	form["MoonDistance"] = round10(moonCoor["distance"]);
	form["MoonDiameter"] = round100(moonCoor["diameter"]*DEG*60); // angular diameter in arc seconds

	// Calculate distance from the observer (on the surface of earth) to the center of the moon
	moonCart = EquPolar2Cart(moonCoor["raGeocentric"], moonCoor["decGeocentric"], moonCoor["distance"]);
	form["MoonDistanceObserver"] = round10( sqrt( pow(moonCart["x"]-observerCart["x"], 2) + pow(moonCart["y"]-observerCart["y"], 2) + pow(moonCart["z"]-observerCart["z"], 2) ));

	moonRise = MoonRise(JD0,form["DeltaT"], lon, lat, form["Zone"], 0);
	form["MoonRise"] = HHMM(moonRise["rise"]);
	form["MoonTransit"] = HHMM(moonRise["transit"]);
	form["MoonSet"] = HHMM(moonRise["set"]);
	return true;
}

// PLANETS
// Source: https://codepen.io/lulunac27/pen/NRoyxE

// day number to/from J2000 (Jan 1.5, 2000)
function day_number( y, m, d, hour, mins )
{
	h = hour + mins/60;
	rv = 367*y
	     - floor(7*(y + floor((m + 9)/12))/4)
	     + floor(275*m/9) + d - 730531.5 + h/24;
	return rv;
}

// compute RA, DEC, and distance of planet-p for day number-d
// result returned in structure obj in degrees and astronomical units
function get_coord( &obj, p, d )
{
	planet = [];
	mean_elements (planet, p, d);
	ap = planet["a"];
	ep = planet["e"];
	ip = planet["i"];
	op = planet["O"];
	pp = planet["w"];
	lp = planet["L"];

	earth = [];
	mean_elements(earth, 2, d);
	ae = earth["a"];
	ee = earth["e"];
	ie = earth["i"];
	oe = earth["O"];
	pe = earth["w"];
	le = earth["L"];

	// position of Earth in its orbit
	me = mod2pi(le - pe);
	ve = true_anomaly(me, ee);
	re = ae*(1 - ee*ee)/(1 + ee*cos(ve));

	// heliocentric rectangular coordinates of Earth
	xe = re*cos(ve + pe);
	ye = re*sin(ve + pe);
	ze = 0.0;

	// position of planet in its orbit
	mp = mod2pi(lp - pp);
	vp = true_anomaly(mp, planet["e"]);
	rp = ap*(1 - ep*ep)/(1 + ep*cos(vp));

	// heliocentric rectangular coordinates of planet
	xh = rp*(cos(op)*cos(vp + pp - op) - sin(op)*sin(vp + pp - op)*cos(ip));
	yh = rp*(sin(op)*cos(vp + pp - op) + cos(op)*sin(vp + pp - op)*cos(ip));
	zh = rp*(sin(vp + pp - op)*sin(ip));

	// calc heliocentric longitude
	lonhp = acos ((xh*rp) / ( sqrt(xh*xh+yh*yh) * sqrt (rp*rp) ));
	if (yh<0)
		lonhp = 360 - lonhp * DEG;
	else
		lonhp = lonhp * DEG;

	if (p == 2) { // earth --> compute sun
		xh = 0;
		yh = 0;
		zh = 0;
	}

	// convert to geocentric rectangular coordinates
	xg = xh - xe;
	yg = yh - ye;
	zg = zh - ze;

	// rotate around x axis from ecliptic to equatorial coords
	ecl = 23.439281*RAD;            //value for J2000.0 frame
	xeq = xg;
	yeq = yg*cos(ecl) - zg*sin(ecl);
	zeq = yg*sin(ecl) + zg*cos(ecl);

	// find the RA and DEC from the rectangular equatorial coords
	obj["ra"]   = mod2pi(atan2(yeq, xeq))*DEG;
	obj["dec"]  = atan(zeq/sqrt(xeq*xeq + yeq*yeq))*DEG;
	obj["rvec"] = sqrt(xeq*xeq + yeq*yeq + zeq*zeq); // distance between earth an planet
	obj["lonh"] = lonhp; // heliocentric longitude
	obj["rsun"] = rp; // distance to sun
}


// Compute the elements of the orbit for planet-i at day number-d
// result is returned in structure p
function mean_elements( &p, i, d )
{
	cy = d/36525;                    // centuries since J2000

	switch (i) {
		case 0: // Mercury
			p["a"] = 0.38709893 + 0.00000066*cy;
			p["e"] = 0.20563069 + 0.00002527*cy;
			p["i"] = ( 7.00487  -  23.51*cy/3600)*RAD;
			p["O"] = (48.33167  - 446.30*cy/3600)*RAD;
			p["w"] = (77.45645  + 573.57*cy/3600)*RAD;
			p["L"] = mod2pi((252.25084 + 538101628.29*cy/3600)*RAD);
			break;
		case 1: // Venus
			p["a"] = 0.72333199 + 0.00000092*cy;
			p["e"] = 0.00677323 - 0.00004938*cy;
			p["i"] = (  3.39471 -   2.86*cy/3600)*RAD;
			p["O"] = ( 76.68069 - 996.89*cy/3600)*RAD;
			p["w"] = (131.53298 - 108.80*cy/3600)*RAD;
			p["L"] = mod2pi((181.97973 + 210664136.06*cy/3600)*RAD);
			break;
		case 2: // Earth/Sun
			p["a"] = 1.00000011 - 0.00000005*cy;
			p["e"] = 0.01671022 - 0.00003804*cy;
			p["i"] = (  0.00005 -    46.94*cy/3600)*RAD;
			p["O"] = (-11.26064 - 18228.25*cy/3600)*RAD;
			p["w"] = (102.94719 +  1198.28*cy/3600)*RAD;
			p["L"] = mod2pi((100.46435 + 129597740.63*cy/3600)*RAD);
			break;
		case 3: // Mars
			p["a"] = 1.52366231 - 0.00007221*cy;
			p["e"] = 0.09341233 + 0.00011902*cy;
			p["i"] = (  1.85061 -   25.47*cy/3600)*RAD;
			p["O"] = ( 49.57854 - 1020.19*cy/3600)*RAD;
			p["w"] = (336.04084 + 1560.78*cy/3600)*RAD;
			p["L"] = mod2pi((355.45332 + 68905103.78*cy/3600)*RAD);
			break;
		case 4: // Jupiter
			p["a"] = 5.20336301 + 0.00060737*cy;
			p["e"] = 0.04839266 - 0.00012880*cy;
			p["i"] = (  1.30530 -    4.15*cy/3600)*RAD;
			p["O"] = (100.55615 + 1217.17*cy/3600)*RAD;
			p["w"] = ( 14.75385 +  839.93*cy/3600)*RAD;
			p["L"] = mod2pi((34.40438 + 10925078.35*cy/3600)*RAD);
			break;
		case 5: // Saturn
			p["a"] = 9.53707032 - 0.00301530*cy;
			p["e"] = 0.05415060 - 0.00036762*cy;
			p["i"] = (  2.48446 +    6.11*cy/3600)*RAD;
			p["O"] = (113.71504 - 1591.05*cy/3600)*RAD;
			p["w"] = ( 92.43194 - 1948.89*cy/3600)*RAD;
			p["L"] = mod2pi((49.94432 + 4401052.95*cy/3600)*RAD);
			break;
		case 6: // Uranus
			p["a"] = 19.19126393 + 0.00152025*cy;
			p["e"] =  0.04716771 - 0.00019150*cy;
			p["i"] = (  0.76986  -    2.09*cy/3600)*RAD;
			p["O"] = ( 74.22988  - 1681.40*cy/3600)*RAD;
			p["w"] = (170.96424  + 1312.56*cy/3600)*RAD;
			p["L"] = mod2pi((313.23218 + 1542547.79*cy/3600)*RAD);
			break;
		case 7: // Neptune
			p["a"] = 30.06896348 - 0.00125196*cy;
			p["e"] =  0.00858587 + 0.00002510*cy;
			p["i"] = (  1.76917  -   3.64*cy/3600)*RAD;
			p["O"] = (131.72169  - 151.25*cy/3600)*RAD;
			p["w"] = ( 44.97135  - 844.43*cy/3600)*RAD;
			p["L"] = mod2pi((304.88003 + 786449.21*cy/3600)*RAD);
			break;
		case 8: // Pluto
			p["a"] = 39.48168677 - 0.00076912*cy;
			p["e"] =  0.24880766 + 0.00006465*cy;
			p["i"] = ( 17.14175  +  11.07*cy/3600)*RAD;
			p["O"] = (110.30347  -  37.33*cy/3600)*RAD;
			p["w"] = (224.06676  - 132.25*cy/3600)*RAD;
			p["L"] = mod2pi((238.92881 + 522747.90*cy/3600)*RAD);
			break;
		default:
			print ("Invalid planet ID");
	}
}

// compute the true anomaly from mean anomaly using iteration
//  M - mean anomaly in radians
//  e - orbit eccentricity
function true_anomaly( M, e )
{
	// initial approximation of eccentric anomaly
	E = M + e*sin(M)*(1.0 + e*cos(M));

	do {                                 // iterate to improve accuracy
		E1 = E;
		E = E1 - (E1 - e*sin(E1) - M)/(1 - e*cos(E1));
	}
	while (abs( E - E1 ) > 1.0e-12);

	// convert eccentric anomaly to true anomaly
	V = 2*atan(sqrt((1 + e)/(1 - e))*tan(0.5*E));

	if (V < 0) V = V + (2*PI);      // modulo 2pi
	return V;
}


// compute horizon coordinates from ra, dec, lat, lon, and utc
// ra, dec, lat, lon in  degrees
// utc is a time number in seconds
//
// results returned in h : horizon record structure
//
function coord_to_horizon( utc, ra, dec, lat, lon, &h )
{
	// compute hour angle in degrees
	ha = mean_sidereal_time(utc, lon) - ra;
	if (ha < 0) ha = ha + 360;

	// convert degrees to radians
	ha  = ha*RAD;
	dec = dec*RAD;
	lat = lat*RAD;

	// compute altitude in radians
	sin_alt = sin(dec)*sin(lat) + cos(dec)*cos(lat)*cos(ha);
	alt     = asin(sin_alt);

	// compute azimuth in radians
	// divide by zero error at poles or if alt = 90 deg
	cos_az = (sin(dec) - sin(alt)*sin(lat))/(cos(alt)*cos(lat));
	az     = acos(cos_az);

	// convert radians to degrees
	h["alt"] = alt*DEG;
	h["az"]  = az*DEG;

	// choose hemisphere
	if (sin(ha) > 0) h["az"]  = 360 - h["az"];
}

// "mean_sidereal_time" returns the Mean Sidereal Time in units of degrees.
// Use lon = 0 to get the Greenwich MST.
// East longitudes are positive; West longitudes are negative
//
// returns: time in degrees
//
function mean_sidereal_time( d, lon )
{
	year   = date("%Y",d);
	month  = date("%m",d);
	day    = date("%j",d);
	hour   = date("%G",d);
	minute = date("%i",d);
	second = date("%s",d);

	if ((month == 1)||(month == 2)) {
		year  = year - 1;
		month = month + 12;
	}

	a = floor(year/100);
	b = 2 - a + floor(a/4);
	c = floor(365.25*year);
	d = floor(30.6001*(month + 1));

	// days since J2000.0
	jd = b + c + d - 730550.5 + day
	     + (hour + minute/60.0 + second/3600.0)/24.0;

	// julian centuries since J2000.0
	jt = jd/36525.0;

	// mean sidereal time
	mst = 280.46061837 + 360.98564736629*jd
	      + 0.000387933*jt*jt - jt*jt*jt/38710000 + lon;

	if (mst > 0.0) {
		while (mst > 360.0)
			mst = mst - 360.0;
	}
	else {
		while (mst < 0.0)
			mst = mst + 360.0;
	}
	return mst;
}

// convert angle (deg, min, sec) to degrees as real
function dms2real( deg, min, sec )
{
	if (deg < 0) rv = deg - min/60 - sec/3600;
	else         rv = deg + min/60 + sec/3600;
	return rv;
}

// converts angle in degrees into string
function degr2str( x )
{
	dec = abs(x);
	sgn = (x < 0) ? "-" : " ";
	d = floor(dec);
	m = 60*(dec - d);
	return sgn.cintstr(d, 3)."째 ".frealstr(m, 4, 1)."'";
}

// converts latitude in signed degrees into string
function lat2str( x)
{
	dec = abs(x);
	sgn = (x < 0) ? " S" : " N";
	d = floor(dec);
	m = 60*(dec - d);
	return cintstr(d, 3)."째 ".frealstr(m, 4, 1)."'".sgn;
}

// converts longitude in signed degrees into string
function lon2str( x)
{
	dec = abs(x);
	sgn = (x < 0) ? " W" : " E";
	d = floor(dec);
	m = 60*(dec - d);
	return cintstr(d, 3)."째 ".frealstr(m, 4, 1)."'".sgn;
}

// format two digits with leading zero if needed
function d2( n )
{
	if ((n < 0)||(99 < n)) return "xx";
	return (n < 10) ? ("0".n) : n;
}

// converts hour angle in degrees into hour angle string
function ha2str( x )
{
	if ((x < 0)||(360 < x))
		return "range error! (".x.")";

	ra = x/15; // degrees to hours
	h = floor(ra);
	m = 60*(ra - h);
	return cintstr(h, 3)."h ".frealstr( m, 4, 1 )."m";
}

// converts declination angle in degrees into string
function dec2str( x )
{
	if ((x < -90)||(90 < x))
		return "range error! (".x.")";

	dec = abs(x);
	sgn = (x < 0) ? "-" : " ";
	d = floor(dec);
	m = 60*(dec - d);
	return sgn.cintstr(d, 2)."째 ".frealstr(m, 4, 1)."'";
}

// format an integer
function cintstr( num, width )
{
	str = intval (num);
	len = strlen (str);
	intgr = "";
	for (i = 0; i < width - len; i++)    // append leading spaces
		intgr .= ' ';

	for (i = 0; i < len; i++)            // append digits
		intgr .= substr (str, i, 1);
	return intgr;
}

function frealstr( num, width, fract )
{
	str = round (num, fract);
	len = strlen (str);
	real = "";
	for (i = 0; i < width - len; i++)    // append leading spaces
		real .= ' ';

	for (i = 0; i < len; i++)            // append digits
		real .= substr (str, i, 1);
	return real;
}

/*
  Compute planet positions
  Form values for input required: Year, Month, Day, Minute, Second, Zone (GMT Hours), Lat, Lon

  Example for Input:

  time = time ();
  form["Hour"]    = date ("%H", time);
  form["Minute"]  = date ("%i", time);
  form["Second"]  = date ("%s", time);
  form["Day"]     = date ("%j", time);
  form["Month"]   = date ("%m", time);
  form["Year"]    = date ("%Y", time);
  form["Zone"]    = date ("%Z", time) / 3600;
  form["Lat"]     = 48.9174128;
  form["Lon"]     = 10.9518465;

  Return array with computed data or false on error. Use print_r () to see details.
*/

function ComputePlanets (&form, pCheck=null)
{
	global planets;
	lat = form["Lat"];
	lon = form["Lon"];

	now = mktime (form["Hour"], form["Minute"], form["Second"], form["Month"], form["Day"], form["Year"]);
	now-=form["Zone"]*3600; // UTC correction

	// compute day number for date/time
	dn = day_number(date("%Y",now), date("%m",now), date("%j",now), date("%H",now), date("%i",now));
	form["JD2000"]=dn;

	JD0 = CalcJD( form["Day"], form["Month"], form["Year"] );
	JD  = JD0 + (( form["Hour"] - form["Zone"]) + form["Minute"]/60 + (form["Second"]/3600)) /24;
	form["JD"]=JD;

	results = [];
	// compute location of objects
	p = intval (pCheck);
	max = count (planets);
	if (pCheck!==null)
		max = pCheck+1;
	for (p; p < max; p++) {
		obj = [];
		h = [];
		get_coord(obj, p, dn);

		coord_to_horizon(now, obj["ra"], obj["dec"], lat, lon, h);

		results[p]= array (
		                "name" => [planets[p], planets[p]],
		                "ra" => [obj["ra"], ha2str (obj["ra"])],
		                "dec" => [obj["dec"], dec2str (obj["dec"])],
		                "az" => [h["az"], degr2str (h["az"])],
		                "alt" =>  [h["alt"], dec2str (h["alt"])],
		                "rvec" => [obj["rvec"], frealstr (obj["rvec"], 11, 6)],
		                "lonh" => [obj["lonh"], frealstr (obj["lonh"], 11, 1)],
		                "rsun" => [obj["rsun"], frealstr (obj["rsun"], 11, 6)]
		            );

	}
	return results;
}


function ComputePlanetsRiseSet (&form, pCheck=null)
{
	global planets;
	deltaT = 65;

	lat = form["Lat"];
	lon = form["Lon"];
	zone = form["Zone"];
	lonr = lon*RAD;
	latr = lat*RAD;
	now = mktime (form["Hour"], form["Minute"], form["Second"], form["Month"], form["Day"], form["Year"]);
	now-=form["Zone"]*3600; // UTC correction

	// compute day number for date/time
	JD2000 = day_number(date("%Y",now), date("%m",now), date("%j",now), date("%H",now), date("%i",now));
	jd0UT2000 = floor(JD2000-0.5)+0.5;   // JD at 0 hours UT

	form["JD2000"]=JD2000;

	JD0 = CalcJD( form["Day"], form["Month"], form["Year"] );
	JD  = JD0 + (( form["Hour"] - form["Zone"]) + form["Minute"]/60 + (form["Second"]/3600)) /24;
	form["JD"]=JD;

	// RA of sun for calculating elongation
	posSun = ComputePlanets (form, 2);
	raSun = posSun[2]["ra"][0];

	results = [];
	// compute location of objects
	p = intval (pCheck);
	max = count (planets);
	if (pCheck!==null)
		max = pCheck+1;
	for (p; p < max; p++) {
		rise = PlanetRise(p, JD, JD2000, deltaT, lonr, latr, zone);

		// Calc positions at rise, set, transit time ...
		hhmmRise = HHMM (rise["rise"], false);
		hhmmSet = HHMM (rise["set"],  false);
		hhmmTransit = HHMM (rise["transit"],  false);

		obj = hRise = hSet = hTransit = [];

		assign (h, m) = explode (":", hhmmRise);
		now = mktime (h, m, 0, form["Month"], form["Day"], form["Year"]) - form["Zone"]*3600;
		JDCheck = day_number(date("%Y",now), date("%m",now), date("%j",now), date("%H",now), date("%i",now));
		get_coord(obj, p, JDCheck);

		if (p==2)
			elongation = 0;
		else {
			elongation = abs (obj["ra"]-raSun);
			if (elongation>180)
				elongation=180-(elongation-180);
		}

		coord_to_horizon(now, obj["ra"], obj["dec"], lat, lon, hRise);

		assign (h, m) = explode (":", hhmmSet);
		now = mktime (h, m, 0, form["Month"], form["Day"], form["Year"]) - form["Zone"]*3600;
		JDCheck = day_number(date("%Y",now), date("%m",now), date("%j",now), date("%H",now), date("%i",now));
		get_coord(obj, p, JDCheck);
		coord_to_horizon(now, obj["ra"], obj["dec"], lat, lon, hSet);

		assign (h, m) = explode (":", hhmmTransit);
		now = mktime (h, m, 0, form["Month"], form["Day"], form["Year"]) - form["Zone"]*3600;
		JDCheck = day_number(date("%Y",now), date("%m",now), date("%j",now), date("%H",now), date("%i",now));
		get_coord(obj, p, JDCheck);
		coord_to_horizon(now, obj["ra"], obj["dec"], lat, lon, hTransit);

		if (rise["set"]<rise["rise"])
			dayLenght = round (rise["set"]+(24-rise["rise"]),2);
		else
			dayLenght = round (rise["set"]-rise["rise"],2);
		if (isNaN (dayLenght)) {
			if (hTransit["alt"]<=0)
				dayLenght = 0;
			else if (hhmmSet=="never" &&  hhmmRise=="never")
				dayLenght = 24;
			else if (hhmmSet=="never") {
				dayLenght = 24-rise["rise"];
			}
			else if (hhmmRise=="never")
				dayLenght = rise["set"];
		}

		results[p]= array (
		                "name" => [planets[p], planets[p]],
		                "rise" => [rise["rise"], hhmmRise],
		                "rise_az" => [hRise["az"], (hhmmRise=="never" ? "  undefined" : degr2str (hRise["az"]))],
		                "set" => [rise["set"], hhmmSet],
		                "set_az" => [hSet["az"], hhmmSet=="never" ? "  undefined" : degr2str (hSet["az"])],
		                "transit" => [rise["transit"], hhmmTransit],
		                "transit_alt" => [hTransit["alt"], frealstr (hTransit["alt"], 5, 1)],
		                "elongation" => [elongation, degr2str (elongation)],
		                "day_length" => [dayLenght, frealstr(dayLenght,5,2)]
		            );
	}
	return results;
}

// Helper function for ComputePlanetsRiseSet ()
function PlanetRise(p, JD, JD2000, deltaT, lon, lat, zone, recursive=false)
{
	obj = [];
	obj2 = [];

	jd0UT2000 = floor(JD2000-0.5)+0.5;   // JD at 0 hours UT
	jd0UT = floor(JD-0.5)+0.5;   // JD at 0 hours UT

	get_coord(obj,  p, jd0UT2000 +    deltaT/24/3600);
	get_coord(obj2, p, jd0UT2000 + 1 +deltaT/24/3600);

	obj["ra"]=deg2rad (obj["ra"]);
	obj["dec"]=deg2rad (obj["dec"]);
	obj2["ra"]=deg2rad (obj2["ra"]);
	obj2["dec"]=deg2rad (obj2["dec"]);

	rise = RiseSet(jd0UT, obj, obj2, lon, lat, 1);

	if (!recursive) {
		if (zone>0) {
			// rise time was yesterday local time -> calculate rise time for next UTC day
			if (rise["rise"]>=24-zone || rise["transit"]>=24-zone || rise["set"]>=24-zone) {
				risetemp = PlanetRise(p, JD+1, JD2000+1, deltaT, lon, lat, zone, 1);
				if (rise["rise"]>=24-zone) rise["rise"] = risetemp["rise"];
				if (rise["transit"] >=24-zone) rise["transit"] = risetemp["transit"];
				if (rise["set"] >=24-zone) rise["set"]  = risetemp["set"];
			}
		}
		else if (zone<0) {
			// rise time was yesterday local time -> calculate rise time for next UTC day
			if (rise["rise"]<-zone || rise["transit"]<-zone || rise["set"]<-zone) {
				risetemp = PlanetRise(p, JD-1, JD2000-1, deltaT, lon, lat, zone, 1);
				if (rise["rise"]<-zone) rise["rise"] = risetemp["rise"];
				if (rise["transit"]<-zone) rise["transit"] = risetemp["transit"];
				if (rise["set"] <-zone) rise["set"]  = risetemp["set"];
			}
		}
		rise["transit"] = fmod(rise["transit"]+zone, 24);
		rise["rise"]    = fmod(rise["rise"]   +zone, 24);
		rise["set"]     = fmod(rise["set"]    +zone, 24);
	}
	return( rise );
}

// Not yet implementes
// Planet positions by VSOP87
// http://neoprogrammics.com/vsop87/source_code_generator_tool/

?>