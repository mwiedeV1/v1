<?v1

dl ("regex");

/**
 * Parses a URI into the components and fragment identifier as specified by RFC 3986.
 * @param url URL to parse
 * @return Array with tokens of parsed URL
 */
function parse_url (url)
{
	r_URI =
	    '^(([a-zA-Z0-9\.\+\-]+):)?'. //  Scheme
	    '(//([^/?#"<>]*))?'. // Authority
	    '([^?#"<>]*)'.       // Path
	    '(\?([^#"<>]*))?'.   // Query
	    '(#([^"<>]*))?'.     // Fragment
	    '/i';
	matches = array();
	result = preg_match(r_URI, url, matches);
	if (!result)
		return false; // *really* invalid URI
	// seperate out parts
	scheme = !empty(matches[1]) ? matches[2] : null;
	authority = !empty(matches[3]) ? matches[4] : null;
	path = matches[5]; // always present, can be empty
	if (empty (path))
		path = "/";
	query = !empty(matches[6]) ? matches[7] : null;
	fragment = !empty(matches[8]) ? matches[9] : null;

	// further parse authority
	if (authority !== null) {
		r_authority = '/^((.+?)@)?(\[[^\]]+\]|[^:]*)(:(\d*))?/';
		matches = array();
		preg_match(r_authority, authority, matches);
		userinfo = !empty(matches[1]) ? matches[2] : null;
		host = !empty(matches[3]) ? matches[3] : '';
		port = !empty(matches[4]) ? intval(matches[5]) : null;
	}
	else {
		port = host = userinfo = null;
	}
	ret = array ("scheme"=>scheme, "userinfo"=>userinfo, "host"=>host, "port" =>port, "path" => path, "query" => query, "fragment" => fragment);
	return ret;
}


/**
 * Format byte size to readable format.
 *
 */
function formatKBText (sizeBytes)
{
	if (sizeBytes>=(1048576*1024))
		return round (sizeBytes / (1048576*1024), 1)." GB";
	else if (sizeBytes>=1048576)
		return round (sizeBytes / 1048576, 1)." MB";
	else if (sizeBytes>=1024)
		return round (sizeBytes / 1024)." KB";
	return sizeBytes." bytes";
}

?>